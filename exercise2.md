
# Архитектура

Архитектура веб-приложения в основном представляет отношения и взаимодействия между такими компонентами, как пользовательские интерфейсы, мониторы обработки транзакций, базы данных и другие. Основная цель - убедиться, что все элементы правильно работают вместе.

Логика довольно проста: когда пользователь вводит URL-адрес в браузере и нажимает «ввод», браузер делает запрос к серверу. Сервер отвечает, а затем показывает требуемую веб-страницу. Все эти компоненты создают архитектуру веб-приложения.
Архитектура веб-приложения в основном представляет отношения и взаимодействия между такими компонентами, как пользовательские интерфейсы, мониторы обработки транзакций, базы данных и другие. Основная цель - убедиться, что все элементы правильно работают вместе.

**Уровни архитектуры веб-приложений:**

* Уровень представления (PL)
* Уровень обслуживания данных (DSL)
* Уровень бизнес-логики (BLL)
* Уровень доступа к данным (DAL)

**Уровень представления**  

PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.

**Слой бизнес-логики** 

BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.

**Уровень службы данных** 

DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.

**Уровень доступа к данным**  

DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.

**Что такое монолитная и микросервисная архитектуры веб-приложения?**

Можно написать всю логику сайта в единственном файле или разбить одну программу на логические модули (например, одна страница - один файл), которые обмениваются информацией друг с другом при необходимости. При первом подходе код будет в одном месте, и файл получится перегруженным. При втором мы имеем порядок, так как каждый модуль будет выполнять только одну функцию.  

Такие программы в IT называют сервисами (программы, как услуги, что-то принимают на вход, что-то делают и что-то отдают нам). В случае, когда продукт написан в одном файле, это монолит (от слова mono - "один"), и архитектура - монолитная. Когда код разнесен по нескольким файлам, это микросервисная архитектура, а сами файлы - микросервисы (то есть, "маленькие" сервисы, являющиеся частью единого целого).

*Монолитная архитектура веб-приложения* означает, что все компоненты приложения находятся в единой кодовой базе, обычно в одном монолитном приложении. Это означает, что все функции приложения  работают как единое целое, что может быть удобно для небольших приложений, но способно вызвать проблемы масштабирования и развития приложения.

*Микросервисная архитектура веб-приложения* означает, что приложение разделено на более мелкие и отдельные компоненты, называемые микросервисами. Каждый микросервис отвечает за выполнение конкретной функции приложения и может быть написан на разных языках программирования. Это позволяет гибко масштабировать и развивать приложение, а также упрощает его тестирование и развертывание. Однако такая архитектура может быть более сложной в реализации и требует от команды разработчиков дополнительных усилий для ее поддержки.

**Каковы различия между монолитом и микросервисами?**
* Сложность приложений: сложным приложениям больше подойдет микросервисная архитектура, а монолиты чаще используются для разработки простых приложений, поскольку их легко создавать и развертывать. Монолит подойдет для разработки простого приложения: это может быть веб-форум, простой магазин или создание пробной версии сайта перед началом более масштабного проекта.  

* Размер команды и навыки разработчиков: одним из решающих факторов при выборе типа архитектуры — количество разработчиков приложения и набор их знаний. Если у команды нет опыта работы с микросервисами и контейнерными системами, то создание микросервисного приложения будет сложным процессом. Монолиты подойдут для одиночных разработчиков или небольших команд. Но, с другой стороны, если команда обладает навыками развертывания микросервисной архитектуры и со временем вы планируете привлечь в команду новых людей, вы можете сэкономить время в будущем, начав работу с микросервисами.  

* Ожидаемый рост приложения: по мере добавления функций монолитные приложения могут становиться все более сложными, что вызовет проблемы с масштабированием при увеличении количества пользователей. Микросервисы обеспечат более легкое масштабирование, если вы ожидаете, что количество пользователей значительно вырастет, а набор функций расширится. Приложения с более ограниченным функционалом часто выигрывают от монолитной архитектуры.  

* Стоимость и время разработки: также следует учитывать стоимость создания приложения и сроки развертывания. По мере роста монолитные приложения могут стоить дороже, но они могут быть рентабельнее и быстрее создаваться. Начальные ресурсы для разработки микросервисов часто большие, но такие приложения могут сэкономить средства при масштабировании в будущем.

*  Устойчивость к сбоям. Отказ одного сервиса не приводит к остановке системы в целом. Когда же ошибка исправлена, необходимое изменение можно развернуть только для соответствующего сервиса — вместо повторного развертывания всего приложения. Правда, для этого еще на этапе проектирования микросервисов потребуется тщательно продумать связи между ними для достижения максимальной независимости друг от друга, а также заложить возможность корректного оповещения пользователя о временной недоступности определенного сервиса без ущерба для всей системы.
* Возможность выбора технологий. Можно подбирать различные наборы технологий, оптимальные для решения задач, стоящих перед отдельными сервисами.

* Уменьшение дублирования функциональностей. Присутствует возможность повторного использования функциональности для различных целей и различными способами.
* Упрощение замены сервисов при необходимости. Небольшие сервисы проще заменить на более подходящую версию или удалить вовсе — это несет значительно меньше рисков по сравнению с монолитным приложением.
* Независимость моделей данных. Каждый микросервис, как правило, использует собственное хранилище данных — поэтому изменение модели данных в одном сервисе не влияет на работу остальных.

**Почему не все приложения построены на микросервисной архитектуре?**

Микросервисная архитектура имеет множество преимуществ, таких как гибкость, масштабируемость, надежность и удобство тестирования. Однако, не все приложения могут эффективно использовать микросервисную архитектуру. Вот несколько причин, по которым не все приложения построены на микросервисной архитектуре:

1. Размер приложения: микросервисная архитектура наиболее эффективна для больших и сложных приложений, которые могут быть разделены на множество микросервисов. Для маленьких приложений монолитная архитектура может быть более подходящей.

2. Сложность разработки: микросервисная архитектура требует высокой степени автоматизации и организации, что может быть сложно для маленьких команд разработки.

3. Сложность управления: управление большим количеством микросервисов может быть сложным и требует дополнительных ресурсов и инструментов. Возможны проблемы с согласованностью из-за применяемого в них децентрализованного управления данными. В монолитном приложении можно выполнить множество связанных изменений за одну транзакцию, и вы будете уверены, что в случае сбоя произойдет откат и согласованность данных сохранится.
Микросервисам же требуется несколько ресурсов для выполнения цепочки изменений, распределенные транзакции не приветствуются — поэтому может возникнуть ситуация, когда при обновлении одного компонента временно перестанет отвечать другой, ожидая завершения операции на первом.
Конечно, при разработке определенных сервисов можно отдать предпочтение не согласованности, а доступности: чтобы в случае обновления или выхода из строя одного сервиса, другие продолжали работу. Но делать это нужно крайне осторожно, чтобы бизнес-логика не принимала решений на основе противоречивой информации


4. Издержки: микросервисная архитектура может быть более дорогой для разработки и поддержки, чем монолитная архитектура.

5. Необходимость высокой доступности: если приложение не требует высокой доступности и надежности, то микросервисная архитектура может быть излишней.

6. Необходимость быстрого развертывания: если приложение не требует быстрого развертывания, то монолитная архитектура может быть достаточной.
7. Распределенная система.  
Микросервисы по своей природе распределены, а это, как известно, имеет свои недостатки: удаленные вызовы медленнее и чаще подвержены сбоям. Если ваш микросервис обращается к десятку других микросервисов, а те, в свою очередь, вызывают еще несколько, то итоговое время отклика значительно возрастает. Также по мере увеличения взаимодействий микросервисов друг с другом возрастает и число возможных точек отказа.

**Каковы особенности тестирования монолитных и микросервисных веб-приложений?**  

**Тестирование монолитных приложений:**

Особенности тестирования монолитных веб-приложений включают в себя:

1. Тестирование функциональности: Необходимо проводить тестирование функциональности, чтобы убедиться, что приложение выполняет свои функции и работает корректно в соответствии с требованиями.

2. Тестирование пользовательского интерфейса: Важно проводить тестирование пользовательского интерфейса, чтобы убедиться, что он интуитивно понятен и удобен для пользователей.

3. Тестирование совместимости: Необходимо проводить тестирование совместимости, чтобы убедиться, что приложение работает корректно на разных браузерах и устройствах.

4. Тестирование производительности: Важно проводить тестирование производительности, чтобы убедиться, что приложение работает быстро и эффективно, особенно при больших нагрузках.

5. Тестирование безопасности: Необходимо проводить тестирование безопасности, чтобы убедиться, что приложение защищено от угроз безопасности, таких как взломы, кражи данных и т. д.

6. Тестирование базы данных: Необходимо проводить тестирование базы данных, чтобы убедиться, что данные сохраняются и извлекаются корректно, и что приложение может управлять большим объемом данных.

7. Тестирование обновлений: Необходимо проводить тестирование обновлений, чтобы убедиться, что приложение работает корректно после обновления и не нарушает работу уже существующей функциональности.

8. Тестирование резервного копирования и восстановления: Необходимо проводить тестирование резервного копирования и восстановления, чтобы убедиться, что приложение может восстановиться после сбоя или сбоя в системе.

Рассмотрим подробнее особенности тестирования.  

**Web-формы**

Формы для заполнения — важнейшие составляющие веб-приложений. Именно с помощью форм осуществляется взаимодействие клиента с сервером (клиент — это, к примеру, веб-браузер, через который пользователь обращается к серверу приложения).  

**Валидация со стороны сервера**  

Представьте, что перед вами стандартная форма входа на сайт с полями для логина и email. Введенные вами значения будут отправлены на сервер и проверены на наличие в базе данных (происходит ***аутентификация***). Если вы уже зарегистрированы и ввели правильные данные, то получите доступ и соответствующие права (происходит ***авторизация***), если нет — увидите сообщение о том, что указанные вами email/логин не существуют.  

**Валидация со стороны клиента**

Речь идет о выполнении проверки значений непосредственно при вводе данных. Для этого в Presentation Layer подключают специальные скрипты валидации (Presentation Layer — слой представления веб-приложения — то, что мы видим, UI).  

**Что такие скрипты могут проверять:**

- ввел ли пользователь в поле email символ @;
- заполнены ли обязательные поля; 
- ввел ли пользователь цифры в поле ввода номера телефона; 
- не совпадают ли поля, которые не должны совпадать, и т. п.  

Для чего это нужно? Ответ очевиден: валидация на стороне клиента уменьшает число обращений к серверу, снижая нагрузку на него.

**База данных**

При тестировании web-приложений не забываем про базы данных. 
**Что проверяем:**
- данные, введенные со стороны клиента, сохранились в базе; 
- данные, записанные в БД, корректно отображаются на клиенте; 
- данные можно удалить/изменить; 
- число открытых соединений с БД; 
- скорость обработки запросов.  

**Сервер**  

Сервер тестируется отдельно от клиента. 
**Проверяем:**
- наличие валидации со стороны сервера (о ней упоминали выше); 
- корректность ответа сервера на подаваемый запрос со стороны клиента (правильный код состояния, заголовок, тело и т. д.) — тут используют такие инструменты, как Fiddler и Postman; 
- скорость обработки запросов.  
 
**Пользователи, multiple users**  

Одновременно с веб-приложением может работать большое число пользователей.  
Какие проверки здесь необходимы:  
- нагрузочное тестирование (сколько пользователей могут без проблем работать одновременно); 
- аутентификация и авторизация (что происходит на стороне сервера); 
- конкурентный (параллельный) доступ к ресурсам (скорость работы приложений не должна меняться); 
- уровни доступа пользователей.


**Тестирование микросервисных приложений:**

Микросервисные приложения имеют следующие особенности тестирования:

1. Тестирование API: Микросервисные приложения построены на основе API, поэтому необходимо проводить тестирование API, чтобы убедиться в правильной работе каждого микросервиса и их взаимодействия.

2. Интеграционное тестирование: Микросервисные приложения включают в себя множество микросервисов, которые работают вместе, поэтому необходимо проводить интеграционное тестирование, чтобы убедиться в правильной работе всей системы в целом.

3. Тестирование безопасности: Микросервисные приложения могут быть уязвимы к различным угрозам безопасности, поэтому необходимо проводить тестирование безопасности, чтобы убедиться, что приложение защищено от атак и данные безопасны.

4. Тестирование отказоустойчивости: В микросервисных приложениях каждый микросервис может работать независимо, поэтому необходимо проводить тестирование отказоустойчивости, чтобы убедиться, что система продолжит работу даже в случае сбоя одного из микросервисов.

5. Тестирование масштабируемости: Микросервисные приложения могут быть масштабированы горизонтально или вертикально, поэтому необходимо проводить тестирование масштабируемости, чтобы убедиться, что приложение может быть масштабировано без проблем и сохранит свою производительность при увеличении количества пользователей и данных.

6. Тестирование функциональности: Необходимо проводить тестирование функциональности, чтобы убедиться, что каждый микросервис выполняет свои функции и работает корректно в соответствии с требованиями.

7. Тестирование пользовательского интерфейса: Важно проводить тестирование пользовательского интерфейса, чтобы убедиться, что он интуитивно понятен и удобен для пользователей.

8. Тестирование совместимости: Необходимо проводить тестирование совместимости, чтобы убедиться, что приложение работает корректно на разных браузерах и устройствах.